<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Octagon Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        Click to start • WASD to move • Mouse to look • Click doors to open
    </div>
    <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Eye height

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Materials
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
        const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const doorFrameMaterial = new THREE.MeshLambertMaterial({ color: 0x4B2F20 });

        // Create octagon hub
        const hubRadius = 20;
        const wallHeight = 4;
        const wallThickness = 0.3;
        const doorWidth = 2;
        const doorHeight = 3;
        const roomDepth = 8;
        const roomWidth = 6;

        // Floor (extended to cover rooms)
        const floorGeometry = new THREE.CircleGeometry(hubRadius + roomDepth + 2, 32);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Calculate wall width for octagon side
        const wallWidth = 2 * hubRadius * Math.tan(Math.PI / 8);

        // Doors and walls
        const doors = [];
        const doorLabels = [
            "Storage", "Library", "Lab", "Office", 
            "Armory", "Medical", "Engine", "Bridge"
        ];

        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI * 2) / 8;
            // const angle = 0;
            
            // Position at the middle of the octagon face
            const centerX = Math.sin(angle) * hubRadius;
            const centerZ = Math.cos(angle) * hubRadius;
            
            // Create a group for this section (wall + door + room)
            const sectionGroup = new THREE.Group();
            sectionGroup.position.set(-centerX, 0, -centerZ);
            // Rotate to face the center
            // sectionGroup.rotation.y = angle + Math.PI / 2;
            sectionGroup.rotation.y = angle;
            scene.add(sectionGroup);

            // Create the main wall with door opening
            const wallSegmentWidth = (wallWidth - doorWidth) / 2;
            
            // Left wall segment
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallSegmentWidth, wallHeight, wallThickness),
                wallMaterial
            );
            leftWall.position.set(-doorWidth/2 - wallSegmentWidth/2, wallHeight/2, 0);
            leftWall.castShadow = true;
            sectionGroup.add(leftWall);

            // Right wall segment
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallSegmentWidth, wallHeight, wallThickness),
                wallMaterial
            );
            rightWall.position.set(doorWidth/2 + wallSegmentWidth/2, wallHeight/2, 0);
            rightWall.castShadow = true;
            sectionGroup.add(rightWall);

            // Door frame
            const doorFrameGroup = new THREE.Group();
            
            // Top frame
            const topFrame = new THREE.Mesh(
                new THREE.BoxGeometry(doorWidth + 0.2, 0.2, wallThickness),
                doorFrameMaterial
            );
            topFrame.position.y = doorHeight;
            doorFrameGroup.add(topFrame);

            // Side frames
            const leftFrame = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, doorHeight, wallThickness),
                doorFrameMaterial
            );
            leftFrame.position.set(-doorWidth/2, doorHeight/2, 0);
            doorFrameGroup.add(leftFrame);

            const rightFrame = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, doorHeight, wallThickness),
                doorFrameMaterial
            );
            rightFrame.position.set(doorWidth/2, doorHeight/2, 0);
            doorFrameGroup.add(rightFrame);

            // Door with pivot
            const doorPivot = new THREE.Group();
            doorPivot.position.set(-doorWidth/2 + 0.05, 0, 0);
            doorPivot.userData = { 
                isOpen: false, 
                angle: 0,
                roomId: i,
                label: doorLabels[i]
            };
            
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(doorWidth - 0.1, doorHeight - 0.1, 0.1),
                doorMaterial
            );
            door.position.set((doorWidth - 0.1)/2, doorHeight/2, 0);
            door.castShadow = true;
            doorPivot.add(door);
            doors.push(doorPivot);
            
            doorFrameGroup.add(doorPivot);
            sectionGroup.add(doorFrameGroup);

            // Add label
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const ctx = labelCanvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = 'black';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(doorLabels[i], 128, 45);

            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const labelMaterial = new THREE.MeshBasicMaterial({ map: labelTexture });
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.4),
                labelMaterial
            );
            label.position.set(0, doorHeight + 0.5, wallThickness/2 + 0.1);
            sectionGroup.add(label);

            // Create room extending outward
            const roomGroup = new THREE.Group();
            roomGroup.position.z = -roomDepth/2 - wallThickness/2;
            
            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                wallMaterial
            );
            backWall.position.set(0, wallHeight/2, -roomDepth/2);
            roomGroup.add(backWall);

            // Left room wall
            const leftRoomWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                wallMaterial
            );
            leftRoomWall.position.set(-roomWidth/2, wallHeight/2, 0);
            roomGroup.add(leftRoomWall);

            // Right room wall
            const rightRoomWall = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                wallMaterial
            );
            rightRoomWall.position.set(roomWidth/2, wallHeight/2, 0);
            roomGroup.add(rightRoomWall);

            // Connect room to doorway with partial walls
            const connectionWidth = (roomWidth - doorWidth) / 2;
            
            const leftConnection = new THREE.Mesh(
                new THREE.BoxGeometry(connectionWidth, wallHeight, wallThickness),
                wallMaterial
            );
            leftConnection.position.set(-roomWidth/2 + connectionWidth/2, wallHeight/2, roomDepth/2);
            roomGroup.add(leftConnection);

            const rightConnection = new THREE.Mesh(
                new THREE.BoxGeometry(connectionWidth, wallHeight, wallThickness),
                wallMaterial
            );
            rightConnection.position.set(roomWidth/2 - connectionWidth/2, wallHeight/2, roomDepth/2);
            roomGroup.add(rightConnection);

            sectionGroup.add(roomGroup);
        }

        // FPS Controls
        let moveForward = false;
        let moveBackward = false;
        let moveRight = false;
        let moveLeft = false;

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Mouse controls
        let isLocked = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        renderer.domElement.addEventListener('click', () => {
            if (!isLocked) {
                renderer.domElement.requestPointerLock();
            } else {
                // Check for door clicks
                checkDoorClick();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (event) => {
            if (!isLocked) return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.005;
            euler.x -= movementY * 0.005;
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyA': moveLeft = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyA': moveLeft = false; break;
            }
        });

        // Door interaction
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2();

        function checkDoorClick() {
            raycaster.setFromCamera(center, camera);
            const doorMeshes = [];
            doors.forEach(doorPivot => {
                doorMeshes.push(doorPivot.children[0]);
            });
            const intersects = raycaster.intersectObjects(doorMeshes);
            
            if (intersects.length > 0) {
                const doorMesh = intersects[0].object;
                const doorPivot = doorMesh.parent;
                if (intersects[0].distance < 5) {
                    doorPivot.userData.isOpen = !doorPivot.userData.isOpen;
                }
            }
        }

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update door animations
            doors.forEach(doorPivot => {
                const targetAngle = doorPivot.userData.isOpen ? Math.PI/2 : 0;
                doorPivot.userData.angle += (targetAngle - doorPivot.userData.angle) * 0.1;
                doorPivot.rotation.y = doorPivot.userData.angle;
            });

            // Update movement
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveBackward) - Number(moveForward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z += direction.z * 40.0 * delta;
            if (moveRight || moveLeft) velocity.x += direction.x * 40.0 * delta;

            const moveVector = new THREE.Vector3();
            moveVector.x = velocity.x * delta;
            moveVector.z = velocity.z * delta;
            moveVector.applyQuaternion(camera.quaternion);

            // Simple collision detection
            const newPos = camera.position.clone().add(moveVector);
            if (Math.abs(newPos.x) < hubRadius + 20 && Math.abs(newPos.z) < hubRadius + 20) {
                camera.position.x += moveVector.x;
                camera.position.z += moveVector.z;
                camera.position.y = 1.6; // Lock Y position to eye height
            }

            camera.position.y = 50;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>